[{"authors":["admin"],"categories":null,"content":"奔波在实现梦想的道路上，享受忙碌的同时也喜欢惬意地驻足留意身边的美景。拥有许多大梦想。也有许多小愿望。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/zh/author/malechi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/zh/author/malechi/","section":"authors","summary":"奔波在实现梦想的道路上，享受忙碌的同时也喜欢惬意地驻足留意身","tags":null,"title":"malechi","type":"authors"},{"authors":[],"categories":[],"content":" \r属性类型  \r数据属性 \r访问器属性 \r读取属性的特性 \r判断是否包含某属性和 in 操作符 \r获取属性  \rfor-in——所有枚举属性 \rObject.keys()——可枚举实例属性的字符串数组 \rObject.getOwnPropertyNames()——所有实例属性的字符串数组 \r注意 console.log()      属性类型 数据属性 [[Configurable]]：表示能否通过 delete 删除属性，能否修改属性特性，能否把属性修改为访问器属性。 [[Enumerable]]：表示能否通过 for-in 循环返回属性。 [[Writable]]：表示是否能修改属性值。 [[Value]]：包含这个属性的数据值，默认值为undefined。\n当直接在对象上定义属性时（即var Person={name:'Joker'}），前三个属性都默认为true。\n修改属性默认的特性的方法——Object.defineProperty()\n在调用 Object.defineProperty()方法创建一个新的属性时，如果不指定considerable，innumerable和writeable特性的默认值都是false。当只是修改一个已定义的属性的特性时，无此限制。\n一旦把属性的considerable定义为false，即，把属性定义为不可配置的，则不能变回可配置了，且修改除writable之外的属性都会发生错误。\nvar Person = {}\rObject.defineProperty(person, 'name', {\rvalue: 'Joker',\t//如果不指定那三个属性，则都默认为false\r})\r// 'use strict' //声明为严格模式\rperson.name = 'rewrite' // 在严格模式下会报错，在非严格模式下下会忽略该语句\r 在非严格模式下，修改已设置writable为false的属性的值，赋值操作将会被忽略；在严格模式下，将抛出错误。\nvar person = {\rname: 'defaultname',\r}\rObject.defineProperty(person, 'name', {\rwritable: false,\t//设置name属性为不可修改\r})\rperson.name = 'rewrite1'\t//重写失败，在非严格模式下会忽略，严格模式下会报错\rconsole.log(person1.name)\t//defaultname\rObject.defineProperty(person1, 'name', {\rwritable: true,\t//重新设置name属性为可修改\r})\rperson1.name = 'rewrite2'\t//可以修改\rconsole.log(person1.name)\t//rewrite2\r 访问器属性 包含getter和setter函数。在读取访问器属性时，会调用get函数负责返回有效的值；在写入访问期属性时会调用set函数并传入新值，负责如何处理数据。 通过Object.defineProperty()来定义。 使用访问器属性的常见方式是，设置一个属性的值会导致其他属性发生变化，如下：\nvar book = {\ryear: 2000,\redition: 1,\r}\rObject.defineProperty(book, 'year', {\rget: function () {\rreturn this.year\r},\rset: function (newValue) {\rif (newValue \u0026gt;= 2000) {\t// 改变year的同时改变edition\rthis.edition = Math.floor((newValue - 2000) / 3) + 1\r}\r},\r})\rbook.year = 2001\rconsole.log(book.edition)\t// 1\rbook.year = 2010\rconsole.log(book.edition)\t// 4\r 只指定getter意味着属性不可写，非严格模式下，尝试写入会被忽略，严格模式下，会抛出错误。 只指定setter意味着属性不可读，非严格模式下，会返回undefined，严格模式下，会抛出错误。\n读取属性的特性 var person = {}\rObject.defineProperty(person, 'name', {\renumerable: false,\rvalue: 'name',\r})\r// 读取属性的特性\rvar descriptor = Object.getOwnPropertyDescriptor(person, 'name')\rconsole.log(descriptor.enumerable) //false\rconsole.log(descriptor.value) //name\r 判断是否包含某属性和 in 操作符 .hasOwnProperty()用于检测一个属性存在于实例中，还是在原型中。当存在于实例中时返回 true。\nfunction Person() {}\rPerson.prototype.name = 'defaultName'\t//添加一个原型属性\rperson.job = 'instanceJob'\t//添加一个实例属性\rconsole.log(person.hasOwnProperty('job')) // true\rconsole.log(person.hasOwnProperty('name')) // false\r in操作符：检测属性是否在实例或原型中，只要包括，就为 true。\nconsole.log('name' in person1) // true\rconsole.log('job' in person1)\t// true\r 结合 in 操作符和 hasOwnProperty()可以判断一个属性是实例属性还是原型属性\nfunction hasPrototypeProperty(obj, name) {\rreturn !obj.hasOwnProperty(name) \u0026amp;\u0026amp; name in obj\r}\rconsole.log(hasPrototypeProperty(person, 'name')) // true\rconsole.log(hasPrototypeProperty(person, 'job')) // false\r 获取属性 for-in——所有枚举属性 // 现在person实例有实例属性name、sayName，原型属性job、sayJob\rfor (let prop in person1) {\rconsole.log(prop) //所有实例属性、原型属性\r}\r 注意let prop in person1中的 prop 的类型是String，因此如果要通过prop访问person1中的属性的值，应使用person1[pop]，而不能使用person1.prop。\n访问 js 对象属性值[]和.的区别：[]中接受的是字符串，如person1[\u0026quot;name\u0026quot;]，而.接受的是直接的属性名，如person1.name。\n被设置为不可枚举，即 emunerable 为 false 的属性在 for..in 中不会被访问到。\nfunction Person() {}\r//定义原型属性，其中一个在后面被设置为不可枚举\rPerson.prototype.protoNameEmun = 'protoNameEmun'\rPerson.prototype.protoNameUnemun = 'protoNameUnemun'\rPerson.prototype.protoSayName = function () {}\rvar person = new Person()\r//定义实例属性，其中一个在后面被设置为不可枚举\rperson.instanceNameEmun = 'instanceNameEmun'\rperson.instanceNameUnemun = 'instanceNameUnemun'\rperson.instanceSayName = function () {}\r// 定义为不可枚举\rObject.defineProperties(person, {\rprotoNameUnemun: {\renumerable: false,\r},\rinstanceNameUnemun: {\renumerable: false,\r},\r})\r// 输出实例属性、原型属性中所有可枚举的，不可枚举的不输出\r// 输出：instanceNameEmun、instanceSayName、protoNameEmun、protoSayName\rfor (let prop in person) {\rconsole.log(prop)\r}\r Object.keys()——可枚举实例属性的字符串数组 Object.keys()方法这个方法接收一个对象作为参数，返回一个包含所有可枚举的实例属性的字符串数组。 同样，对于上述的例子：\nvar key1 = Object.keys(Person.prototype)\rvar key2 = Object.keys(person)\rconsole.log(key1)\t//[ 'protoNameEmun', 'protoNameUnemun', 'protoSayName' ]\rconsole.log(key2)\t//[ 'instanceNameEmun', 'instanceSayName' ]\r Object.getOwnPropertyNames()——所有实例属性的字符串数组 返回包含所有实例属性（不论是否可以枚举）的字符串数组。\nvar names1 = Object.getOwnPropertyNames(Person.prototype)\rvar names2 = Object.getOwnPropertyNames(person)\rconsole.log(names1)\r// [ 'constructor', 'protoNameEmun', 'protoNameUnemun', 'protoSayName' ]\rconsole.log(names2)\r// [ 'instanceNameEmun', 'instanceNameUnemun', 'instanceSayName', 'protoNameUnemun' ]\r 注意在 name1 中包含了不可枚举属性 constructor，正说明了“不论是否可以枚举”这一点。\n注意 console.log() 在 vscode 中 console.log(obj)出来的对象，显示的只有实例属性。 假设SuperType中包括实例属性和方法name, sayName，包括原型方法sayProto，则：\n// 自定义一个能打印出所有实例属性、原型属性的方法，使用for..in\rfunction printAllProps(obj) {\rlet array = []\rfor (let prop in obj) {\rarray.push(prop)\r}\rconsole.log(array)\r}\rvar obj = new SuperType('Joker')\rconsole.log(obj)\rprintAllProps(obj)\r 最后两行在 vscode 中打印出来的内容分别为： SuperType { name: 'Joker', sayName: [Function] } [ 'name', 'sayName', 'sayProto' ]\n可以看到，原型上的sayProto方法并没有在console.log中打印出来。\n","date":1588087362,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1588087362,"objectID":"be21fe045183e8d9b253fa0300bf5d09","permalink":"/zh/post/js-properties/","publishdate":"2020-04-28T23:22:42+08:00","relpermalink":"/zh/post/js-properties/","section":"post","summary":"属性类型 数据属性 访问器属性 读取属性的特性 判断是否包含某属性和","tags":[],"title":"Js Properties","type":"post"},{"authors":[],"categories":["JavaScript进阶之路"],"content":" \r定义函数  \r函数声明 \r函数表达式   \r函数的使用  \r作为其他函数参数 \r作为其他函数的返回值 \r递归 \r执行环境、作用域链、活动对象 \r闭包    定义函数 定义函数有两种方式，总结这两种定义函数的特性和适应情况如下。\n函数声明 function func() {}\r 特征：\n 函数声明提升（可以把函数声明放在调用它的语句后面）  函数表达式 var func = function () {};\r 特征：\n 此时创建的是匿名函数 必须在使用前赋值（即不存在提升）  适合使用 函数表达式 的情况：\n 根据condition赋值不同函数（如if-else）  var condition_func;\rvar condition = false;\rif (condition) {\rcondition_func = function () {\rconsole.log(\u0026quot;in if\u0026quot;);\r};\r} else {\rcondition_func = function () {\rconsole.log(\u0026quot;in else\u0026quot;);\r};\r}\rcondition_func(); // in else\r 函数的使用 作为其他函数参数 逆序排列数组，将reverse函数作为参数传递给sort()。\nfunction reverse(a, b) {\rreturn b - a;\r}\rvar arr = new Array(\u0026quot;10\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;40\u0026quot;);\rconsole.log(arr.sort(reverse));\r 输出结果为，验证正确：\n[\u0026quot;40\u0026quot;, \u0026quot;10\u0026quot;, \u0026quot;5\u0026quot;];\r 作为其他函数的返回值 对象数组，按照其中某一属性值排序。\nfunction sortByProp(propertyname) {\rreturn function (obj1, obj2) {\rlet val1 = obj1[propertyname];\rlet val2 = obj2[propertyname];\rreturn val1 - val2;\r};\r}\rvar persons = [\r{\rname: \u0026quot;Jake\u0026quot;,\rage: 28,\r},\r{\rname: \u0026quot;Maria\u0026quot;,\rage: 23,\r},\r{\rname: \u0026quot;Jimmy\u0026quot;,\rage: 15,\r},\r];\rconsole.log(persons.sort(sortByProp(\u0026quot;age\u0026quot;)));\r 输出结果为，验证正确：\n[\r{ name: \u0026quot;Jimmy\u0026quot;, age: 15 },\r{ name: \u0026quot;Maria\u0026quot;, age: 23 },\r{ name: \u0026quot;Jake\u0026quot;, age: 28 },\r];\r 递归 一般递归形式如下：\nfunction func() {\rfunc();\r}\r 但此时存在一个可能的问题，如果想把函数保存在一个变量中，通过变量调用时就会出现问题。\nfunction func() {\r// do sth ...\rfunc();\r}\rvar anotherfunc = func;\rfunc = null; // 只有anotherfunc一个指向函数的引用\ranotherfunc(); // 出错\r 原因：在执行函数时会包括执行名为func的函数，但此时func已被解引用。\n解决方案：使用arguments.callee代替函数名——一个指向正在执行的函数的指针，适合于实现函数的递归调用。\nfunction func() {\r// do sth ...\rarguments.callee(); // ! important\r}\rvar anotherfunc = func;\rfunc = null;\ranotherfunc();\r 执行环境、作用域链、活动对象 变量对象和活动对象\n变量对象（VO）：与执行上下文概念对应，包含了执行上下文中的所有变量、函数以及当前执行上下文函数的参数列表。\n活动对象（AO）：进入到执行阶段之后，变量对象转变成了活动对象。\n作用域链\n本质上是一个指向变量对象的指针列表，只引用但不实际包含变量对象。\n在函数中访问一个变量时，会从作用域中搜索具有相应名字的变量\n作用域链是怎么创建的\n在函数被创建时，首先创建一个执行环境、以及相应的作用域链。再使用arguments和其他命名参数的值来初始化函数的活动对象。\n在函数执行过程中，需要在作用域中查找变量。从作用域链链首开始寻找。\n先回顾一下变量提升、函数声明提升\n变量提升：变量的定义提升（注意块级作用域中，用let声明的变量不存在变量提升），但赋值不提升。\nconsole.log(a); // undefined\rvar a = 10;\r 函数声明提升\nf(); // doing sth...\rfunction f() {\rconsole.log(\u0026quot;doing sth...\u0026quot;);\r}\r 综合来看，可以得知一下代码会输出如下结果 （如果不知道为什么，请先回顾一下变量提升和函数声明提升的内容）：\na(); // function\rvar a = function () {\rconsole.log(\u0026quot;anonymous\u0026quot;);\r};\rfunction a() {\rconsole.log(\u0026quot;function\u0026quot;);\r}\r var a = function () {\rconsole.log(\u0026quot;anonymous\u0026quot;);\r};\rfunction a() {\rconsole.log(\u0026quot;function\u0026quot;);\r}\ra(); // anonymous\r var a = \u0026quot;global a\u0026quot;; // 语句1\rfunction b() {\rconsole.log(\u0026quot;global b()\u0026quot;);\r}\rfunction c(a, b) {\rarguments[1](); // 输出：inner b()，可以看出此处的b已经是inner funciton\rb(); // inner b()\rconsole.log(a); // global a，语句2\rvar a = \u0026quot;inner a\u0026quot;;\rfunction b() {\rconsole.log(\u0026quot;inner b()\u0026quot;);\r}\r}\rc(a, b); // 每步骤输出见上\rb(); // global b()\r 有以下关键点：\n 运行到 语句 1 但还未执行时：  \r 进入函数 c 的执行时，内部函数 b 因为函数声明提升，会将参数 b 的值改为指向这个内部函数 b 。  作用域链是怎样创建的\n在创建c()函数时，会创建一个预先包含全局变量对象的作用域链，该作用域链会被保存在内部的[[Scope]]属性中。\n当调用c()函数时，会为函数创建一个执行环境，然后复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。\n然后，又有一个活动对象被创建，并推入执行环境作用域链的前端。\n闭包 首先要明确闭包和匿名函数的概念。闭包是指有权访问另一个函数作用域中的变量的函数。（划重点：要访问另一个函数作用域中的变量）\n创建方式\n常见方式就是在一个函数内部创建另一个函数。\n","date":1587990885,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587990885,"objectID":"ed897c02386f58e830e2414d291abae3","permalink":"/zh/post/js-function/","publishdate":"2020-04-27T20:34:45+08:00","relpermalink":"/zh/post/js-function/","section":"post","summary":"定义函数 函数声明 函数表达式 函数的使用 作为其他函数参数 作为其他","tags":[],"title":"Js Function","type":"post"},{"authors":[],"categories":["JavaScript进阶之路"],"content":" \rnew 操作的实现原理 \r使用原型链进行继承  \rinstanceof 操作符、isPrototypeOf() 方法 \r问题   \r借用构造函数  \r问题   \r组合继承  \r不足：会调用两次超类型构造函数   \r原型式继承 \r寄生式继承 \r寄生组合式继承  new 操作的实现原理 以 SuperType 构造函数和 obj 实例为例。\n首先明确 new 操作符的预期结果：\n obj 具有 SuperType 所有的实例属性、方法和原型属性、方法 obj.constructor === SuperType, 返回 true obj.__proto__ == SuperType.prototype, 返回 true obj 上的原型方法与 SuperType 原型上的同一方法在内存上应该一致 new 操作最后返回了一个对象 obj instanceof SuperType, 返回 true  先给出 SuperType 构造函数的定义：\nfunction SuperType() {\rthis.prop = true;\rthis.func = function () {};\r}\rSuperType.prototype.protofunc = function () {};\r 验证上述几个 new 操作符的预期结果是否正确：\nvar obj1 = new SuperType();\rconsole.log(obj1.constructor === SuperType); // true\rconsole.log(obj1.__proto__ == SuperType.prototype); // true\rconsole.log(obj1.protofunc === SuperType.prototype.protofunc); // true\rconsole.log(obj1 instanceof SuperType); // true\r 返回结果都为 true，说明上述预期是正确的。\n接下来，开始复现 new 操作符的实现过程。封装在函数newinstance(Type)中，其中，Type 为对象类型，即相当于SuperType。\nfunction newinstance(Type) {\r// 首先创建一个对象实例，该对象包括一个 __proto__ 属性，需要指向 Type.prototype\rvar o = {\r__proto__: Type.prototype,\r};\r// 接着，对象实例 o 需要具有 Type 的所有实例属性和原型属性\r// 即，在o对象实例上运行 Type 的构造函数，初始化 Type 的那些属性和方法\rType.apply(o);\r// 最后，需要返回这个对象实例\rreturn o;\r}\r 对该复现进行验证，验证是否满足上述预期结果。\n// 首先定义函数printAllProps()，用于输出所有可枚举的实例属性、原型属性\r// 不用console.log输出的原因见获得对象属性的方法的博文\rfunction printAllProps(obj) {\rlet array = [];\rfor (let prop in obj) {\rarray.push(prop);\r// 如果要输出属性值，使用：\r// array.push(prop + ':' + obj[prop])\r}\rconsole.log(array);\r}\r var obj = newinstance(SuperType);\rprintAllProps(obj);\r 输出['prop', 'func', 'protofunc']，说明已经满足具有所有实例属性、原型属性的预期。\nconsole.log(obj.constructor === SuperType); // true\rconsole.log(obj.__proto__ == SuperType.prototype); // true\rconsole.log(obj.protofunc === SuperType.prototype.protofunc); // true\rconsole.log(obj instanceof SuperType); // true\r 全部输出true，说明这一步也验证正确。\n至此，new 操作符的重现已经完成。\n使用原型链进行继承 继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。\n本质是重写原型对象，用另一个类型的实例所代替。\nfunction SuperType() {\rthis.prop = true;\rthis.func = function () {};\r}\rSuperType.prototype.protofunc = function () {};\rfunction SubType() {\rthis.subprop = true;\rthis.subfunc = function () {};\r}\rSubType.prototype = new SuperType(); // !important\rvar subobj = new SubType();\r 上述代码中，SubType.prototype = new SuperType() 给 SubType 换了一个新的原型，因为是直接重写的。SubType.prototype指向的是这个新new出来的对象。因此最终结果为，subobj 中有一个指向SubType.prototype的指针，SubType.prototype中有一个指向SuperType.prototype的指针。\n\r使用原型链实现继承时，在继承类型中，不能使用对象字面量创建原型方法或属性。\n例如，不能使用以下字面量添加新方法。本质问题是错误地将原型对象重写替换成了另一个对象字面量。\nSubType.prototype = new SuperType();\r// 错误方法\r// SubType.prototype = {\r// newfunc: function () {},\r// };\r// 正确方法\rSubType.prototype.newfunc = function () {};\r instanceof 操作符、isPrototypeOf() 方法 所有引用类型都默认继承了 Object。\ninstanceof\n只要这个构造函数在实例的原型链中出现过，就返回 true。\nconsole.log(subobj instanceof SubType); // true\rconsole.log(subobj instanceof SuperType); // true\rconsole.log(subobj instanceof Object); // true\r isPrototypeOf()\n只要是在原型链中出现过的原型，都可以算作该原型链所派生的实例的原型，返回 true。\nconsole.log(SubType.prototype.isPrototypeOf(subobj)); // true\rconsole.log(SuperType.prototype.isPrototypeOf(subobj)); // true\rconsole.log(Object.prototype.isPrototypeOf(subobj)); // true\r 问题 问题一：对于包含引用类型值的子类型原型，即超类型实例属性、原型属性中包含引用类型的时候，子类型对象公用这些引用类型内存，对引用类型值的更改会反映在所有对象上。\n问题二：创建子类型对象时，不能在不影响所有对象实例的情况下向超类型构造函数传递参数。\n借用构造函数 也称伪造对象继承或经典继承。\n本质是，在子类型构造函数内部调用超类型构造函数，同时使用call()和apply()方法在新创建的子类型对象上执行构造函数。\n可以解决使用原型链实现继承的问题一和问题二。\nfunction SuperType(supername) {\rthis.name = supername;\rthis.arrays = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\rthis.func = function () {};\r}\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // !important\r// 为了确保SuperType构造函数不会重写子类型的属性\r// 应先调用超类型构造函数，再进行子类型属性定义\rthis.subname = subname;\r}\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rsubobj1.arrays.push(\u0026quot;3\u0026quot;);\rvar subobj2 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rvar superobj = new SuperType(\u0026quot;super\u0026quot;);\r 使用可以输出可枚举属性名、属性值的printAllProps()函数，验证对引用类型值的更改是否影响到了所有对象实例。\nprintAllProps(subobj1);\r// [ 'subname:sub', 'name:super', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(subobj2);\r// [ 'subname:sub', 'name:super', 'arrays:1,2', 'func:function () {}' ]\rprintAllProps(superobj);\r// [ 'name:super', 'arrays:1,2', 'func:function () {}']\r 原因： 使用call()方法，即在新要创建的子类型对象上执行了SuperType()函数中定义的对象初始化代码，每个SubType类型实例都具有自己的arrays副本。\n但这同时也带来了借用构造函数继承的问题。\n问题  方法都在构造函数中定义，无法进行函数复用。  console.log(subobj1.func === subobj2.func); // false\r  在超类型原型中定义的方法，对子类型是不可见的。  如果给SuperType类型添加原型函数protofunc()如下：\nSuperType.prototype.protofunc = function () {};\r 在SubType对象实例subobj1、subobj2中将不会包含这个超类型的原型方法，printAllProps()结果将如下：\nprintAllProps(subobj1); // [ 'subname:sub', 'name:super', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(subobj2); // [ 'subname:sub', 'name:super', 'arrays:1,2', 'func:function () {}' ]\rprintAllProps(superobj); // [ 'name:super', 'arrays:1,2', 'func:function () {}', 'protofunc:function () {}']\r 可以看到，只有superobj中包含了该方法。原因：注意上一段中的加粗字体：执行了SuperType()函数中定义的对象初始化代码——原型上的属性方法不是定义在SuperType()构造函数中的，构造函数中仅包含实例属性方法,因此子类型SubType的实例中将只会初始化这些实例属性方法。\n导致的结果是，所有类型都只能使用构造函数模式。因此借用构造函数很少单独使用。\n组合继承 也称伪经典继承, 将原型链和借用构造函数组合在一起，融合了二者的优点：\n 使用借用构造函数实现对实例属性的继承 使用原型链实现对原型属性的继承  // 定义超类型的实例属性方法\rfunction SuperType(supername) {\rthis.name = supername;\rthis.arrays = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\r}\r// 定义超类型的原型属性方法\rSuperType.prototype.protofunc = function () {};\rSuperType.prototype.protonames = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;];\r// 子类型开始继承\r// 1. 使用借用构造函数实现对实例属性的继承\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // !important\rthis.subname = subname;\r}\r// 2. 使用原型链实现对原型属性的继承\rSubType.prototype = new SuperType(); // !important\rSubType.prototype.constructor = SubType; // !important\r// 创建子类型对象实例\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rvar subobj2 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\r 虽然组合继承目前被使用得很多，但仍有不足。\n不足：会调用两次超类型构造函数 无论在什么情况下，使用组合继承都会调用两次超类型构造函数：第一次，在重写SubType的原型时；第二次，在子类型SubType构造函数内部。如下：\nfunction SuperType(supername) {\rthis.name = supername;\r}\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // 第二次调用\rthis.subname = subname;\r}\rSubType.prototype = new SuperType(); // 第一次调用\rSubType.prototype.constructor = SubType;\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;); // 第二次调用入口\r 实际过程如下：\n 第一次调用时，SubType.prototype中会存在属性name，来自于SuperType的实例属性。 第二次调用时，子类型对象实例上会存在实例属性name、subname，由于实例属性会屏蔽原型属性中的同名属性，真实使用的是实例属性name，而原型属性name会被屏蔽。  这也就是组合继承中效率较低的地方。解决方法见寄生组合式继承。\n原型式继承 适用情况：只是想让一个对象与另一个对象保持类似的情况下，添加新的属性和方法。\n不涉及到类型（function），从头到尾使用的都是对象（var）。\n// 注意这是个对象，而不是类型构造函数\r// 使用字面量对象、对象实例都可以\rvar obj = {\rname: \u0026quot;objname\u0026quot;,\rarrays: [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;],\rfunc: function () {},\r};\r// Object.create()方法的两种参数形式\rvar anotherobj1 = Object.create(obj);\rvar anotherobj2 = Object.create(obj, {\rname: {\renumerable: true,\rvalue: \u0026quot;newname\u0026quot;,\r},\r});\r Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\nObject.create()方法有两种参数形式：\n  第一个参数：一个作为新对象原型的对象\n  第二个参数（可选）：为新对象定义新属性的对象，形式与 Object.defineProperties()的第二个参数格式相同\n  特别注意第二个参数中，属性name的那四种数据属性，如果没有指定enumerable: true，在使用for..in和printAllProps时，属性不会被枚举到。\n修改anotherobj1的arrays的值，如下：\nanotherobj1.arrays.push(\u0026quot;3\u0026quot;);\rprintAllProps(anotherobj1); // [ 'name:objname', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(anotherobj2); // [ 'name:newname', 'arrays:1,2,3', 'func:function () {}' ]\r 可以看到，使用原型式继承，同样也会存在使用原型链进行继承时的引用类型值的问题——包含引用类型值的属性始终会共享相应的值。\n可通过以下代码验证：\nconsole.log(anotherobj1.arrays === anotherobj2.arrays); // true\rconsole.log(anotherobj1.func === anotherobj2.func); // true```\r 寄生式继承 适用情况：在主要考虑的是对象，而不是自定义类型或构造函数时。\nfunction createAnother(original) {\r// 该Object()函数不是必须，任何返回一个对象的函数都可以\rvar clone = Object(original);\rclone.newfunc = function () {};\rreturn clone;\r}\rvar original = {\rname: \u0026quot;originalName\u0026quot;,\r};\rvar another = createAnother(original);\rprintAllProps(another); // [ 'name:originalName', 'newfunc:function () {}' ]\r 缺点：与构造函数继承类似地，函数不能复用。\n寄生组合式继承 优点：高效率——弥补组合继承的不足，只调用一次超类型SuperType构造函数，避免了在子类型SubType的原型prototype上创建不必要的多余的属性和方法。\n是目前引用类型最理想的继承范式。\n本质：使用寄生式继承来继承超类型的原型（即只继承了超类型的原型属性，并没有在子类型原型上添加超类型实例属性），然后再将结果指定给子类型的原型。即，将组合继承中第一次调用超类型构造函数的地方进行了替换。\nfunction SuperType(supername) {\rthis.name = supername;\r}\rSuperType.prototype.protofunc = function () {};\rfunction SubType(subname, supername) {\rthis.subname = subname;\rSuperType.call(this, supername);\r}\r// 用以下方式替换组合继承中的第一次调用\r// 即，替换掉 SubType.prototype = new SuperType()\r// *************************************\rfunction inheritPrototype(subType, superType) {\rvar prototype = superType.prototype; // 创建原型对象\rprototype.constructor = subType; // 增强对象\rsubType.prototype = prototype; // 指定原型对象\r}\rinheritPrototype(SubType, SuperType);\r// *************************************\rSubType.prototype.constructor = SubType;\rvar subobj = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rprintAllProps(subobj); // [ 'subname:sub', 'name:super', 'protofunc:function () {}' ]\r 为创建的超类型原型副本prototype添加constructor属性的目的：弥补因重写而失去的默认的constructor属性，让prototype副本有正确的constructor属性指向。\n","date":1587820942,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587820942,"objectID":"5e9b9a2df192e82048fde76b4cc49c21","permalink":"/zh/post/js-inherit/","publishdate":"2020-04-25T21:22:22+08:00","relpermalink":"/zh/post/js-inherit/","section":"post","summary":"new 操作的实现原理 使用原型链进行继承 instanceof 操作符、isProtot","tags":[],"title":"JS 继承方法详解","type":"post"},{"authors":[],"categories":["JavaScript进阶之路"],"content":" \r工厂模式 \r构造函数模式 \r原型模式  \r原型与原型链 \r构造函数、原型和实例的关系 \r原型的动态性 \r原型模式的缺点   \r组合使用构造函数模式和原型模式（用得最多） \r动态原型模式 \r寄生构造函数模式 \r稳妥构造函数模式  工厂模式 本质：用函数封装创建对象的细节。\n特点：\n 显式创建了对象（如Object） 不使用new 有return语句 缺点：没有解决对象识别问题，即怎样知道一个对象的类型。（如代码倒数第二行的false）  function createPerson(name, age) {\rvar o = new Object();\ro.name = name;\ro.age = age;\ro.sayName = function () {};\rreturn o;\r}\rvar person = createPerson(\u0026quot;Joker\u0026quot;, 23);\rconsole.log(person instanceof createPerson); // false\rconsole.log(person.__proto__); //{}\r 构造函数模式 特点：\n 没有显式创建对象 直接将属性和方法赋给了this对象 没有return语句 创建新实例需使用new操作符 可以解决工厂模式不能确定对象类型的问题 缺点：会导致不同实例中的方法不是同一个Function实例，导致不同的作用域链和标识符解析。（同一个名为sayName 的方法在不同实例中是不同 Function 对象）（如代码倒数第三行的false）  function Person(name, age) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\rthis.sayName = function () {};\r}\rvar person1 = new Person(\u0026quot;Joker\u0026quot;, 23);\rvar person2 = new Person(\u0026quot;Joker1\u0026quot;, 24);\rperson1.friends.push(\u0026quot;3\u0026quot;);\rconsole.log(person1.friends); //[ '1', '2', '3' ]\rconsole.log(person2.friends); //[ '1', '2' ]\rconsole.log(person1.sayName === person2.sayName); //false\rconsole.log(person1 instanceof Person); //true\rconsole.log(person1.__proto__); //Person {}\r 原型模式 原型与原型链 我们创建的每个函数都有一个 prototype 属性，即原型属性。prototype 属性是一个指针，指向一个包含可以由特定类型的所有实例共享的属性和方法的对象。\nprototype 就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处是可以让所有对象实例共享包含的属性和方法。\n构造函数、原型和实例的关系 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n什么叫让所有对象实例共享包含的属性和方法\n直接在对象实例上定义方法的缺点是，不同对象实例中包含的方法不是同一个 Function 实例——在 ECMAScript 中的函数是对象，每定义一个函数，就是实例化一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析。\n而使用原型对象则可以做到让所有对象实例共享包含的属性和方法。\nfunction Person() {}\rPerson.prototype={\rname : 'defaultName',\rage = 'defaultAge'\r}\rPerson.prototype.sayName = function () {\rconsole.log(this.name)\r}\rvar person1 = new Person()\rvar person2 = new Person()\r//使用原型对象的好处，可以让所有对象实例共享它所包含的属性和方法\rconsole.log(person1.sayName == person2.sayName) // true\r 原型链\n\r有关方法\nObjectName.prototype.isPrototypeOf(instanceName) 实例 instanceName 的原型是否是 ObjectName.prototype。\nObject.getPrototypeOf(instanceName) 获取实例 instanceName 的原型的名称。\nvar person = new Person();\rconsole.log(Person.prototype.isPrototypeOf(person)); // true\rconsole.log(Object.getPrototypeOf(person) == Person.prototype); //true\r 原型的动态性 对原型对象的修改会及时体现在实例上，就算在实例创建以后。\nvar person1 = new Person();\rPerson.prototype.sayHi = function () {\rconsole.log(\u0026quot;sayHi\u0026quot;);\r};\rperson1.sayHi(); // sayHi\r 但是，如果重写整个原型对象，情况则会不一样。\nvar person2 = new Person();\rPerson.prototype = {\rsayName: function () {\rconsole.log(\u0026quot;sayName\u0026quot;);\r},\r};\rperson2.sayName(); // person2.sayName is not a function\r 原因如下图，初始化 person2 时与原来的 Person.prototype 有联系，重写了 Person.prototype 之后相当于新 new 了一个出来，与原来那个已经不是同一个了。\n\r在此之后，如果再新建对象实例，则会与新 new 的 prototype 建立联系，会拥有新 prototype 上面的属性，但不会拥有原 prototype 上的属性。\nvar person3 = new Person();\rconsole.log(person3.name); // undefined\rperson3.sayName(); // sayName\r \r原型模式的缺点 本质是原型中的所有属性被很多实例共享的问题。对于是基本类型值的属性不要紧，但是对于引用类型属性，更改一个实例上的该属性值，会导致所有实例中的该属性值都被更改——因为改引用类型值是存在于对象原型 Prototype 上的，而不是对象实例中。\nfunction Person() {}\rPerson.prototype = {\rarrays: [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;],\r};\rvar person1 = new Person();\rvar person2 = new Person();\rperson1.arrays.push(\u0026quot;3\u0026quot;);\rconsole.log(person1.arrays); // [ '1', '2', '3' ]\rconsole.log(person2.arrays); // [ '1', '2', '3' ]\r 因此，很少单独使用原型模式。\n组合使用构造函数模式和原型模式（用得最多） 为解决上述问题，组合使用构造函数模式与原型模式。\n优点：构造函数模式用于定义实例，原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，又共享着对方法的引用，最大限度的节省了内存。这种混成模式还支持向构造函数传递参数。\n// 1. 构造函数模式\rfunction Person(name, age) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;];\r}\r// 2. 原型模式\rPerson.prototype = {\rconstructor: Person, //会让constructor变为可枚举的属性\rsayName: function () {\rconsole.log(this.name);\r},\r};\rvar person3 = new Person(\u0026quot;Joker\u0026quot;, 23);\rvar person4 = new Person(\u0026quot;Rekoj\u0026quot;, 32);\r// 共用方法（通过原型定义）\r// 但引用类型的属性不会相互干扰（通过构造函数模式定义）\rperson3.friends.push(\u0026quot;fox\u0026quot;);\rconsole.log(person3.friends); // [ 'A', 'B', 'fox' ]\rconsole.log(person4.friends); // [ 'A', 'B' ]\rconsole.log(person3.friends === person4.friends); // false\rconsole.log(person3.sayName === person4.sayName); //true\r 其中，为Person.prototype添加constructor属性的目的：弥补因重写原型而失去的默认的constructor属性。添加constructor属性的操作会使constructor变为可枚举的属性。\n动态原型模式 原理跟组合使用构造函数模式和原型模式一样，但是把原型定义操作封装在了构造函数中。本质是通过构造函数初始化原型。\n在构造函数中的 if 语句是为了判断是否在该对象上定义了sayName的方法——也就是说，当Person的原型上还未定义sayName方法时（如第一次执行new Person(...)语句时），if语句会执行，即进行原型的初始化；一旦 Person 的原型被初始化过（如第二次执行new Person(...)语句时），根据原型的动态性，sayName已被定义，不会再进入 if 语句中。\nfunction Person(name, age, job) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;];\rif (typeof this.sayName != \u0026quot;function\u0026quot;) {\r// !important\rPerson.prototype.sayName = function () {\rconsole.log(this.name);\r};\r}\r}\rvar person3 = new Person(\u0026quot;Joker\u0026quot;, 23, \u0026quot;tricker\u0026quot;);\rvar person4 = new Person(\u0026quot;Rekoj\u0026quot;, 32, \u0026quot;rekcirt\u0026quot;);\rperson3.friends.push(\u0026quot;fox\u0026quot;);\rconsole.log(person3.friends);\rconsole.log(person4.friends);\rconsole.log(person3.friends === person4.friends);\rconsole.log(person3.sayName === person4.sayName);\r 且如果原型上需要定义多个方法和属性，也只需要一个if语句判断，选其中一个属性或方法判断即可。\n要特别注意的是，if语句中的Person.prototype不能使用对象字面量重写原型，原因之前说过，会切断现有实例与新原型之间的联系。\n寄生构造函数模式 使用情况：如，想创建一个具有额外方法的特殊数组，由于不能直接写修改 Array 构造函数，因此可以使用这个模式。\n特点：\n 不能依赖 instanceof 操作符来确定对象类型（如下面的例子，array 是 instanceof Array，但不是 SpecialArray） 使用new操作符  function SpecialArray() {\rvar values = new Array();\rvalues.push.apply(values, arguments);\rvalues.toSpecialString = function () {\rreturn this.join(\u0026quot;+\u0026quot;);\r};\rreturn values;\r}\rvar array = new SpecialArray(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;);\rconsole.log(array.toSpecialString()); // a+b+c\rconsole.log(array instanceof SpecialArray); // false\rconsole.log(array.__proto__); // []\rconsole.log(array instanceof Array); // true\r 稳妥构造函数模式 特点：\n 适用于一些安全的环境中（如会禁止使用this和new），或防止数据被其它应用程序改动（如只允许通过方法访问到属性值） 新创建对象的实例方法不使用this 不适用new操作符 不能依赖 instanceof 操作符来确定对象类型（跟寄生构造函数模式类似）  function Person(name, age) {\rvar o = new Object();\ro.sayName = function () {\rconsole.log(name);\r};\rreturn o;\r}\rvar person = Person(\u0026quot;Joker\u0026quot;, 23);\rconsole.log(person.name); //undefined\rperson.sayName(); //Joker\r ","date":1587805618,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587805618,"objectID":"3b99f1f19ccb93a68587808e1c8a6ab1","permalink":"/zh/post/js-createobj/","publishdate":"2020-04-25T17:06:58+08:00","relpermalink":"/zh/post/js-createobj/","section":"post","summary":"工厂模式 构造函数模式 原型模式 原型与原型链 构造函数、原型和实例","tags":[],"title":"JS 创建对象模式","type":"post"}]