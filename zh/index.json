[{"authors":["admin"],"categories":null,"content":"奔波在实现梦想的道路上，享受忙碌的同时也喜欢惬意地驻足留意身边的美景。拥有许多大梦想。也有许多小愿望。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/zh/author/malechi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/zh/author/malechi/","section":"authors","summary":"奔波在实现梦想的道路上，享受忙碌的同时也喜欢惬意地驻足留意身","tags":null,"title":"malechi","type":"authors"},{"authors":[],"categories":["JavaScript进阶之路"],"content":" \rnew 操作的实现原理 \r使用原型链进行继承  \rinstanceof 操作符、isPrototypeOf() 方法 \r问题   \r借用构造函数  \r问题   \r组合继承  \r不足：会调用两次超类型构造函数   \r原型式继承 \r寄生式继承 \r寄生组合式继承  new 操作的实现原理 以 SuperType 构造函数和 obj 实例为例。\n首先明确 new 操作符的预期结果：\n obj 具有 SuperType 所有的实例属性、方法和原型属性、方法 obj.constructor === SuperType, 返回 true obj.__proto__ == SuperType.prototype, 返回 true obj 上的原型方法与 SuperType 原型上的同一方法在内存上应该一致 new 操作最后返回了一个对象 obj instanceof SuperType, 返回 true  先给出 SuperType 构造函数的定义：\nfunction SuperType() {\rthis.prop = true;\rthis.func = function () {};\r}\rSuperType.prototype.protofunc = function () {};\r 验证上述几个 new 操作符的预期结果是否正确：\nvar obj1 = new SuperType();\rconsole.log(obj1.constructor === SuperType); // true\rconsole.log(obj1.__proto__ == SuperType.prototype); // true\rconsole.log(obj1.protofunc === SuperType.prototype.protofunc); // true\rconsole.log(obj1 instanceof SuperType); // true\r 返回结果都为 true，说明上述预期是正确的。\n接下来，开始复现 new 操作符的实现过程。封装在函数newinstance(Type)中，其中，Type 为对象类型，即相当于SuperType。\nfunction newinstance(Type) {\r// 首先创建一个对象实例，该对象包括一个 __proto__ 属性，需要指向 Type.prototype\rvar o = {\r__proto__: Type.prototype,\r};\r// 接着，对象实例 o 需要具有 Type 的所有实例属性和原型属性\r// 即，在o对象实例上运行 Type 的构造函数，初始化 Type 的那些属性和方法\rType.apply(o);\r// 最后，需要返回这个对象实例\rreturn o;\r}\r 对该复现进行验证，验证是否满足上述预期结果。\n// 首先定义函数printAllProps()，用于输出所有可枚举的实例属性、原型属性\r// 不用console.log输出的原因见获得对象属性的方法的博文\rfunction printAllProps(obj) {\rlet array = [];\rfor (let prop in obj) {\rarray.push(prop);\r// 如果要输出属性值，使用：\r// array.push(prop + ':' + obj[prop])\r}\rconsole.log(array);\r}\r var obj = newinstance(SuperType);\rprintAllProps(obj);\r 输出['prop', 'func', 'protofunc']，说明已经满足具有所有实例属性、原型属性的预期。\nconsole.log(obj.constructor === SuperType); // true\rconsole.log(obj.__proto__ == SuperType.prototype); // true\rconsole.log(obj.protofunc === SuperType.prototype.protofunc); // true\rconsole.log(obj instanceof SuperType); // true\r 全部输出true，说明这一步也验证正确。\n至此，new 操作符的重现已经完成。\n使用原型链进行继承 继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。\n本质是重写原型对象，用另一个类型的实例所代替。\nfunction SuperType() {\rthis.prop = true;\rthis.func = function () {};\r}\rSuperType.prototype.protofunc = function () {};\rfunction SubType() {\rthis.subprop = true;\rthis.subfunc = function () {};\r}\rSubType.prototype = new SuperType(); // !important\rvar subobj = new SubType();\r 上述代码中，SubType.prototype = new SuperType() 给 SubType 换了一个新的原型，因为是直接重写的。SubType.prototype指向的是这个新new出来的对象。因此最终结果为，subobj 中有一个指向SubType.prototype的指针，SubType.prototype中有一个指向SuperType.prototype的指针。\n\r使用原型链实现继承时，在继承类型中，不能使用对象字面量创建原型方法或属性。\n例如，不能使用以下字面量添加新方法。本质问题是错误地将原型对象重写替换成了另一个对象字面量。\nSubType.prototype = new SuperType();\r// 错误方法\r// SubType.prototype = {\r// newfunc: function () {},\r// };\r// 正确方法\rSubType.prototype.newfunc = function () {};\r instanceof 操作符、isPrototypeOf() 方法 所有引用类型都默认继承了 Object。\ninstanceof\n只要这个构造函数在实例的原型链中出现过，就返回 true。\nconsole.log(subobj instanceof SubType); // true\rconsole.log(subobj instanceof SuperType); // true\rconsole.log(subobj instanceof Object); // true\r isPrototypeOf()\n只要是在原型链中出现过的原型，都可以算作该原型链所派生的实例的原型，返回 true。\nconsole.log(SubType.prototype.isPrototypeOf(subobj)); // true\rconsole.log(SuperType.prototype.isPrototypeOf(subobj)); // true\rconsole.log(Object.prototype.isPrototypeOf(subobj)); // true\r 问题 问题一：对于包含引用类型值的子类型原型，即超类型实例属性、原型属性中包含引用类型的时候，子类型对象公用这些引用类型内存，对引用类型值的更改会反映在所有对象上。\n问题二：创建子类型对象时，不能在不影响所有对象实例的情况下向超类型构造函数传递参数。\n借用构造函数 也称伪造对象继承或经典继承。\n本质是，在子类型构造函数内部调用超类型构造函数，同时使用call()和apply()方法在新创建的子类型对象上执行构造函数。\n可以解决使用原型链实现继承的问题一和问题二。\nfunction SuperType(supername) {\rthis.name = supername;\rthis.arrays = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\rthis.func = function () {};\r}\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // !important\r// 为了确保SuperType构造函数不会重写子类型的属性\r// 应先调用超类型构造函数，再进行子类型属性定义\rthis.subname = subname;\r}\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rsubobj1.arrays.push(\u0026quot;3\u0026quot;);\rvar subobj2 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rvar superobj = new SuperType(\u0026quot;super\u0026quot;);\r 使用可以输出可枚举属性名、属性值的printAllProps()函数，验证对引用类型值的更改是否影响到了所有对象实例。\nprintAllProps(subobj1);\r// [ 'subname:sub', 'name:super', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(subobj2);\r// [ 'subname:sub', 'name:super', 'arrays:1,2', 'func:function () {}' ]\rprintAllProps(superobj);\r// [ 'name:super', 'arrays:1,2', 'func:function () {}']\r 原因： 使用call()方法，即在新要创建的子类型对象上执行了SuperType()函数中定义的对象初始化代码，每个SubType类型实例都具有自己的arrays副本。\n但这同时也带来了借用构造函数继承的问题。\n问题  方法都在构造函数中定义，无法进行函数复用。  console.log(subobj1.func === subobj2.func); // false\r  在超类型原型中定义的方法，对子类型是不可见的。  如果给SuperType类型添加原型函数protofunc()如下：\nSuperType.prototype.protofunc = function () {};\r 在SubType对象实例subobj1、subobj2中将不会包含这个超类型的原型方法，printAllProps()结果将如下：\nprintAllProps(subobj1); // [ 'subname:sub', 'name:super', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(subobj2); // [ 'subname:sub', 'name:super', 'arrays:1,2', 'func:function () {}' ]\rprintAllProps(superobj); // [ 'name:super', 'arrays:1,2', 'func:function () {}', 'protofunc:function () {}']\r 可以看到，只有superobj中包含了该方法。原因：注意上一段中的加粗字体：执行了SuperType()函数中定义的对象初始化代码——原型上的属性方法不是定义在SuperType()构造函数中的，构造函数中仅包含实例属性方法,因此子类型SubType的实例中将只会初始化这些实例属性方法。\n导致的结果是，所有类型都只能使用构造函数模式。因此借用构造函数很少单独使用。\n组合继承 也称伪经典继承, 将原型链和借用构造函数组合在一起，融合了二者的优点：\n 使用借用构造函数实现对实例属性的继承 使用原型链实现对原型属性的继承  // 定义超类型的实例属性方法\rfunction SuperType(supername) {\rthis.name = supername;\rthis.arrays = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\r}\r// 定义超类型的原型属性方法\rSuperType.prototype.protofunc = function () {};\rSuperType.prototype.protonames = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;];\r// 子类型开始继承\r// 1. 使用借用构造函数实现对实例属性的继承\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // !important\rthis.subname = subname;\r}\r// 2. 使用原型链实现对原型属性的继承\rSubType.prototype = new SuperType(); // !important\rSubType.prototype.constructor = SubType; // !important\r// 创建子类型对象实例\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rvar subobj2 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\r 虽然组合继承目前被使用得很多，但仍有不足。\n不足：会调用两次超类型构造函数 无论在什么情况下，使用组合继承都会调用两次超类型构造函数：第一次，在重写SubType的原型时；第二次，在子类型SubType构造函数内部。如下：\nfunction SuperType(supername) {\rthis.name = supername;\r}\rfunction SubType(subname, supername) {\rSuperType.call(this, supername); // 第二次调用\rthis.subname = subname;\r}\rSubType.prototype = new SuperType(); // 第一次调用\rSubType.prototype.constructor = SubType;\rvar subobj1 = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;); // 第二次调用入口\r 实际过程如下：\n 第一次调用时，SubType.prototype中会存在属性name，来自于SuperType的实例属性。 第二次调用时，子类型对象实例上会存在实例属性name、subname，由于实例属性会屏蔽原型属性中的同名属性，真实使用的是实例属性name，而原型属性name会被屏蔽。  这也就是组合继承中效率较低的地方。解决方法见寄生组合式继承。\n原型式继承 适用情况：只是想让一个对象与另一个对象保持类似的情况下，添加新的属性和方法。\n不涉及到类型（function），从头到尾使用的都是对象（var）。\n// 注意这是个对象，而不是类型构造函数\r// 使用字面量对象、对象实例都可以\rvar obj = {\rname: \u0026quot;objname\u0026quot;,\rarrays: [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;],\rfunc: function () {},\r};\r// Object.create()方法的两种参数形式\rvar anotherobj1 = Object.create(obj);\rvar anotherobj2 = Object.create(obj, {\rname: {\renumerable: true,\rvalue: \u0026quot;newname\u0026quot;,\r},\r});\r Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\nObject.create()方法有两种参数形式：\n  第一个参数：一个作为新对象原型的对象\n  第二个参数（可选）：为新对象定义新属性的对象，形式与 Object.defineProperties()的第二个参数格式相同\n  特别注意第二个参数中，属性name的那四种数据属性，如果没有指定enumerable: true，在使用for..in和printAllProps时，属性不会被枚举到。\n修改anotherobj1的arrays的值，如下：\nanotherobj1.arrays.push(\u0026quot;3\u0026quot;);\rprintAllProps(anotherobj1); // [ 'name:objname', 'arrays:1,2,3', 'func:function () {}' ]\rprintAllProps(anotherobj2); // [ 'name:newname', 'arrays:1,2,3', 'func:function () {}' ]\r 可以看到，使用原型式继承，同样也会存在使用原型链进行继承时的引用类型值的问题——包含引用类型值的属性始终会共享相应的值。\n可通过以下代码验证：\nconsole.log(anotherobj1.arrays === anotherobj2.arrays); // true\rconsole.log(anotherobj1.func === anotherobj2.func); // true```\r 寄生式继承 适用情况：在主要考虑的是对象，而不是自定义类型或构造函数时。\nfunction createAnother(original) {\r// 该Object()函数不是必须，任何返回一个对象的函数都可以\rvar clone = Object(original);\rclone.newfunc = function () {};\rreturn clone;\r}\rvar original = {\rname: \u0026quot;originalName\u0026quot;,\r};\rvar another = createAnother(original);\rprintAllProps(another); // [ 'name:originalName', 'newfunc:function () {}' ]\r 缺点：与构造函数继承类似地，函数不能复用。\n寄生组合式继承 优点：高效率——弥补组合继承的不足，只调用一次超类型SuperType构造函数，避免了在子类型SubType的原型prototype上创建不必要的多余的属性和方法。\n是目前引用类型最理想的继承范式。\n本质：使用寄生式继承来继承超类型的原型（即只继承了超类型的原型属性，并没有在子类型原型上添加超类型实例属性），然后再将结果指定给子类型的原型。即，将组合继承中第一次调用超类型构造函数的地方进行了替换。\nfunction SuperType(supername) {\rthis.name = supername;\r}\rSuperType.prototype.protofunc = function () {};\rfunction SubType(subname, supername) {\rthis.subname = subname;\rSuperType.call(this, supername);\r}\r// 用以下方式替换组合继承中的第一次调用\r// 即，替换掉 SubType.prototype = new SuperType()\r// *************************************\rfunction inheritPrototype(subType, superType) {\rvar prototype = superType.prototype; // 创建原型对象\rprototype.constructor = subType; // 增强对象\rsubType.prototype = prototype; // 指定原型对象\r}\rinheritPrototype(SubType, SuperType);\r// *************************************\rSubType.prototype.constructor = SubType;\rvar subobj = new SubType(\u0026quot;sub\u0026quot;, \u0026quot;super\u0026quot;);\rprintAllProps(subobj); // [ 'subname:sub', 'name:super', 'protofunc:function () {}' ]\r 为创建的超类型原型副本prototype添加constructor属性的目的：弥补因重写而失去的默认的constructor属性，让prototype副本有正确的constructor属性指向。\n","date":1587820942,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587820942,"objectID":"5e9b9a2df192e82048fde76b4cc49c21","permalink":"/zh/post/js-inherit/","publishdate":"2020-04-25T21:22:22+08:00","relpermalink":"/zh/post/js-inherit/","section":"post","summary":"new 操作的实现原理 使用原型链进行继承 instanceof 操作符、isProtot","tags":[],"title":"JS 继承方法详解","type":"post"},{"authors":[],"categories":["JavaScript进阶之路"],"content":" \r工厂模式 \r构造函数模式 \r原型模式  \r原型与原型链 \r构造函数、原型和实例的关系 \r原型的动态性 \r原型模式的缺点   \r组合使用构造函数模式和原型模式（用得最多） \r动态原型模式 \r寄生构造函数模式 \r稳妥构造函数模式  工厂模式 本质：用函数封装创建对象的细节。\n特点：\n 显式创建了对象（如Object） 不使用new 有return语句 缺点：没有解决对象识别问题，即怎样知道一个对象的类型。（如代码倒数第二行的false）  function createPerson(name, age) {\rvar o = new Object();\ro.name = name;\ro.age = age;\ro.sayName = function () {};\rreturn o;\r}\rvar person = createPerson(\u0026quot;Joker\u0026quot;, 23);\rconsole.log(person instanceof createPerson); // false\rconsole.log(person.__proto__); //{}\r 构造函数模式 特点：\n 没有显式创建对象 直接将属性和方法赋给了this对象 没有return语句 创建新实例需使用new操作符 可以解决工厂模式不能确定对象类型的问题 缺点：会导致不同实例中的方法不是同一个Function实例，导致不同的作用域链和标识符解析。（同一个名为sayName 的方法在不同实例中是不同 Function 对象）（如代码倒数第三行的false）  function Person(name, age) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;];\rthis.sayName = function () {};\r}\rvar person1 = new Person(\u0026quot;Joker\u0026quot;, 23);\rvar person2 = new Person(\u0026quot;Joker1\u0026quot;, 24);\rperson1.friends.push(\u0026quot;3\u0026quot;);\rconsole.log(person1.friends); //[ '1', '2', '3' ]\rconsole.log(person2.friends); //[ '1', '2' ]\rconsole.log(person1.sayName === person2.sayName); //false\rconsole.log(person1 instanceof Person); //true\rconsole.log(person1.__proto__); //Person {}\r 原型模式 原型与原型链 我们创建的每个函数都有一个 prototype 属性，即原型属性。prototype 属性是一个指针，指向一个包含可以由特定类型的所有实例共享的属性和方法的对象。\nprototype 就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处是可以让所有对象实例共享包含的属性和方法。\n构造函数、原型和实例的关系 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。\n什么叫让所有对象实例共享包含的属性和方法\n直接在对象实例上定义方法的缺点是，不同对象实例中包含的方法不是同一个 Function 实例——在 ECMAScript 中的函数是对象，每定义一个函数，就是实例化一个对象。以这种方式创建函数，会导致不同的作用域链和标识符解析。\n而使用原型对象则可以做到让所有对象实例共享包含的属性和方法。\nfunction Person() {}\rPerson.prototype={\rname : 'defaultName',\rage = 'defaultAge'\r}\rPerson.prototype.sayName = function () {\rconsole.log(this.name)\r}\rvar person1 = new Person()\rvar person2 = new Person()\r//使用原型对象的好处，可以让所有对象实例共享它所包含的属性和方法\rconsole.log(person1.sayName == person2.sayName) // true\r 原型链\n\r有关方法\nObjectName.prototype.isPrototypeOf(instanceName) 实例 instanceName 的原型是否是 ObjectName.prototype。\nObject.getPrototypeOf(instanceName) 获取实例 instanceName 的原型的名称。\nvar person = new Person();\rconsole.log(Person.prototype.isPrototypeOf(person)); // true\rconsole.log(Object.getPrototypeOf(person) == Person.prototype); //true\r 原型的动态性 对原型对象的修改会及时体现在实例上，就算在实例创建以后。\nvar person1 = new Person();\rPerson.prototype.sayHi = function () {\rconsole.log(\u0026quot;sayHi\u0026quot;);\r};\rperson1.sayHi(); // sayHi\r 但是，如果重写整个原型对象，情况则会不一样。\nvar person2 = new Person();\rPerson.prototype = {\rsayName: function () {\rconsole.log(\u0026quot;sayName\u0026quot;);\r},\r};\rperson2.sayName(); // person2.sayName is not a function\r 原因如下图，初始化 person2 时与原来的 Person.prototype 有联系，重写了 Person.prototype 之后相当于新 new 了一个出来，与原来那个已经不是同一个了。\n\r在此之后，如果再新建对象实例，则会与新 new 的 prototype 建立联系，会拥有新 prototype 上面的属性，但不会拥有原 prototype 上的属性。\nvar person3 = new Person();\rconsole.log(person3.name); // undefined\rperson3.sayName(); // sayName\r \r原型模式的缺点 本质是原型中的所有属性被很多实例共享的问题。对于是基本类型值的属性不要紧，但是对于引用类型属性，更改一个实例上的该属性值，会导致所有实例中的该属性值都被更改——因为改引用类型值是存在于对象原型 Prototype 上的，而不是对象实例中。\nfunction Person() {}\rPerson.prototype = {\rarrays: [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;],\r};\rvar person1 = new Person();\rvar person2 = new Person();\rperson1.arrays.push(\u0026quot;3\u0026quot;);\rconsole.log(person1.arrays); // [ '1', '2', '3' ]\rconsole.log(person2.arrays); // [ '1', '2', '3' ]\r 因此，很少单独使用原型模式。\n组合使用构造函数模式和原型模式（用得最多） 为解决上述问题，组合使用构造函数模式与原型模式。\n优点：构造函数模式用于定义实例，原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，又共享着对方法的引用，最大限度的节省了内存。这种混成模式还支持向构造函数传递参数。\n// 1. 构造函数模式\rfunction Person(name, age) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;];\r}\r// 2. 原型模式\rPerson.prototype = {\rconstructor: Person, //会让constructor变为可枚举的属性\rsayName: function () {\rconsole.log(this.name);\r},\r};\rvar person3 = new Person(\u0026quot;Joker\u0026quot;, 23);\rvar person4 = new Person(\u0026quot;Rekoj\u0026quot;, 32);\r// 共用方法（通过原型定义）\r// 但引用类型的属性不会相互干扰（通过构造函数模式定义）\rperson3.friends.push(\u0026quot;fox\u0026quot;);\rconsole.log(person3.friends); // [ 'A', 'B', 'fox' ]\rconsole.log(person4.friends); // [ 'A', 'B' ]\rconsole.log(person3.friends === person4.friends); // false\rconsole.log(person3.sayName === person4.sayName); //true\r 其中，为Person.prototype添加constructor属性的目的：弥补因重写原型而失去的默认的constructor属性。添加constructor属性的操作会使constructor变为可枚举的属性。\n动态原型模式 原理跟组合使用构造函数模式和原型模式一样，但是把原型定义操作封装在了构造函数中。本质是通过构造函数初始化原型。\n在构造函数中的 if 语句是为了判断是否在该对象上定义了sayName的方法——也就是说，当Person的原型上还未定义sayName方法时（如第一次执行new Person(...)语句时），if语句会执行，即进行原型的初始化；一旦 Person 的原型被初始化过（如第二次执行new Person(...)语句时），根据原型的动态性，sayName已被定义，不会再进入 if 语句中。\nfunction Person(name, age, job) {\rthis.name = name;\rthis.age = age;\rthis.friends = [\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;];\rif (typeof this.sayName != \u0026quot;function\u0026quot;) {\r// !important\rPerson.prototype.sayName = function () {\rconsole.log(this.name);\r};\r}\r}\rvar person3 = new Person(\u0026quot;Joker\u0026quot;, 23, \u0026quot;tricker\u0026quot;);\rvar person4 = new Person(\u0026quot;Rekoj\u0026quot;, 32, \u0026quot;rekcirt\u0026quot;);\rperson3.friends.push(\u0026quot;fox\u0026quot;);\rconsole.log(person3.friends);\rconsole.log(person4.friends);\rconsole.log(person3.friends === person4.friends);\rconsole.log(person3.sayName === person4.sayName);\r 且如果原型上需要定义多个方法和属性，也只需要一个if语句判断，选其中一个属性或方法判断即可。\n要特别注意的是，if语句中的Person.prototype不能使用对象字面量重写原型，原因之前说过，会切断现有实例与新原型之间的联系。\n寄生构造函数模式 使用情况：如，想创建一个具有额外方法的特殊数组，由于不能直接写修改 Array 构造函数，因此可以使用这个模式。\n特点：\n 不能依赖 instanceof 操作符来确定对象类型（如下面的例子，array 是 instanceof Array，但不是 SpecialArray） 使用new操作符  function SpecialArray() {\rvar values = new Array();\rvalues.push.apply(values, arguments);\rvalues.toSpecialString = function () {\rreturn this.join(\u0026quot;+\u0026quot;);\r};\rreturn values;\r}\rvar array = new SpecialArray(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;);\rconsole.log(array.toSpecialString()); // a+b+c\rconsole.log(array instanceof SpecialArray); // false\rconsole.log(array.__proto__); // []\rconsole.log(array instanceof Array); // true\r 稳妥构造函数模式 特点：\n 适用于一些安全的环境中（如会禁止使用this和new），或防止数据被其它应用程序改动（如只允许通过方法访问到属性值） 新创建对象的实例方法不使用this 不适用new操作符 不能依赖 instanceof 操作符来确定对象类型（跟寄生构造函数模式类似）  function Person(name, age) {\rvar o = new Object();\ro.sayName = function () {\rconsole.log(name);\r};\rreturn o;\r}\rvar person = Person(\u0026quot;Joker\u0026quot;, 23);\rconsole.log(person.name); //undefined\rperson.sayName(); //Joker\r ","date":1587805618,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587805618,"objectID":"3b99f1f19ccb93a68587808e1c8a6ab1","permalink":"/zh/post/js-createobj/","publishdate":"2020-04-25T17:06:58+08:00","relpermalink":"/zh/post/js-createobj/","section":"post","summary":"工厂模式 构造函数模式 原型模式 原型与原型链 构造函数、原型和实例","tags":[],"title":"JS 创建对象模式","type":"post"}]